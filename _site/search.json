[
  {
    "objectID": "posts/welcome/index.html",
    "href": "posts/welcome/index.html",
    "title": "Welcome To My Blog",
    "section": "",
    "text": "This is the first post in a Quarto blog. Welcome!\n\nSince this post doesn’t specify an explicit image, the first image in the post will be used in the listing page of posts."
  },
  {
    "objectID": "projects.html",
    "href": "projects.html",
    "title": "Projects",
    "section": "",
    "text": "Tic tac toe\n\n\nA classic Tic Tac Toe game developed using JavaScript, HTML, and CSS."
  },
  {
    "objectID": "projects.html#tic-tac-toe",
    "href": "projects.html#tic-tac-toe",
    "title": "Projects",
    "section": "",
    "text": "Tic tac toe\n\n\nA classic Tic Tac Toe game developed using JavaScript, HTML, and CSS."
  },
  {
    "objectID": "projects.html#another-project",
    "href": "projects.html#another-project",
    "title": "Projects",
    "section": "Another Project",
    "text": "Another Project\n\n\n\nAnother Project\n\n\nBrief description of another project."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "blog",
    "section": "",
    "text": "01 Intro to Machine Learning\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "Hello, I’m Elvis. I’m a full-stack developer who enjoys learning new things and building web apps."
  },
  {
    "objectID": "posts/01_intro/index.html",
    "href": "posts/01_intro/index.html",
    "title": "01 Intro to Machine Learning",
    "section": "",
    "text": "Goal: Build an image recognizer\n\n! pip install duckduckgo-search\n\n\nfrom duckduckgo_search import DDGS\nfrom fastcore.all import *\n\ndef search_images(term, max_images=30):\n    \"\"\"\n    Search for images using DuckDuckGo's search engine\n    \n    Parameters:\n    - term: search term/query (e.g., \"cars\", \"bikes\")\n    - max_images: maximum number of images to return (default 30)\n    \n    Returns:\n    - List of image URLs\n    \"\"\"\n    print(f\"Searching for '{term}'\")\n    \n    with DDGS() as ddgs:  # Create a DuckDuckGo search session\n        # Process:\n        # 1. Search for images using ddgs.images()\n        # 2. Convert results to fastcore's List type\n        # 3. Extract just the image URLs\n        return L(ddgs.images(term, max_results=max_images)).itemgot('image')\n\nLet’s start by searching for a car photo and seeing what kind of result we get. We’ll start by getting URLs from a search:\n\n# get images urls, in this case just 1 url\nurls =  search_images('car photos',max_images=1)\nurls[0]\n\nSearching for 'car photos'\n\n\n'https://wallup.net/wp-content/uploads/2017/11/23/533023-Lamborghini-car-car_show-photography-black_cars-luxury_cars.jpg'\n\n\n..and then download a URL and take a look at it:Now let’s do the same with “bicycle” and “electric scooter”:\n\nfrom fastdownload import download_url\ndest = 'car.jpg'\ndownload_url(urls[0], dest, show_progress=False)\n\nfrom fastai.vision.all import *\nim = Image.open(dest)\nim.to_thumb(256,256)\n\n\n\n\n\n\n\n\nNow let’s do the same with “bicycle”:\n\ndownload_url(search_images('bicycle photos', max_images=1)[0], 'bicycle.jpg', show_progress=False)\nImage.open('bicycle.jpg').to_thumb(256,256)\n\nSearching for 'bicycle photos'\n\n\n\n\n\n\n\n\n\nThe same with electric scooters\n\ndownload_url(search_images('electric scooter photos', max_images=1)[0], 'scooter.jpg', show_progress=False)\nImage.open('scooter.jpg').to_thumb(256,256)\n\nSearching for 'electric scooter photos'\n\n\n\n\n\n\n\n\n\nOur searches seem to be giving reasonable results. Let’s grab a few examples of each of “car”, “bicycle” and “electric scooter” photos and save each group of photos to a different folder. We will search for day and night photos to grab a range of lighting conditions.\n\nsearches = 'car','bicycle','electric scooter'\npath = Path('car_bicycle_or_scooter')\nfrom time import sleep\n\nfor o in searches:\n    # destination, create a directory if it doesnt exist, then download images for the o term\n    # resize the images \n    dest = path/o # car_bicycle_or_scooter/car \n    dest.mkdir(exist_ok=True, parents=True)\n    download_images(dest, urls=search_images(f'{o} photo'))\n    sleep(10)  # Pause between searches to avoid over-loading server\n    download_images(dest, urls=search_images(f'{o} sun photo'))\n    sleep(10)\n    download_images(dest, urls=search_images(f'{o} shade photo'))\n    sleep(10)\n    resize_images(path/o, max_size=400, dest=path/o)     \n\nSearching for 'car photo'\nSearching for 'car sun photo'\nSearching for 'car shade photo'\nSearching for 'bicycle photo'\nSearching for 'bicycle sun photo'\nSearching for 'bicycle shade photo'\nSearching for 'electric scooter photo'\nSearching for 'electric scooter sun photo'\nSearching for 'electric scooter shade photo'\n\n\nFolders structure after executing the code above:\n\n\n\nStep 2: train our model\nSome photos might not download correctly which could cause our model training to fail, so we’ll remove them:\n\nfailed = verify_images(get_image_files(path))\nfailed.map(Path.unlink)\nlen(failed)\n\n10\n\n\nUnderstanding DataLoaders To train a model, we’ll need DataLoaders, which is an object that contains:\nA training set (the images used to create the model) A validation set (the images used to check the accuracy of a model)\nWhat goes into the DataLoaders object? Out of hundreds of projects, what are all the things that change from project to project to get the data in the right shape? We can split it down into these components:\n\nInput and Output Types\n\nInput: Images\nOutput: Categories (car, bicycle, electric scooter)\n\nGetting Items (get_items)\n\nGets all image files from the specified path\nRuns the get_image_files function\nReturns a list of all image files in a path\nLooks through directories recursively\n\nData Splitting (splitter)\n\nSplits the data into training and validation sets randomly\nUses 20% of the data for the validation set\n\nLabeling (get_y=parent_label)\n\nUses the parent folder name as the category label\nExample:\n\n\ncar_bicycle_or_scooter/car/image1.jpg → label is “car” car_bicycle_or_scooter/bicycle/image2.jpg → label is “bicycle”\n\nImage Preprocessing\n\nBefore training, resize each image to 192x192 pixels\nUses “squish” method (as opposed to cropping)\n‘squish’ method maintains aspect ratio\n\nDataLoader Creation\n\ndataloaders(path, bs=32)\nCreates train and validation dataloaders\nbs=32 means batch size of 32 images\n\n\n\ndls = DataBlock(\n    blocks=(ImageBlock, CategoryBlock), \n    get_items=get_image_files, \n    splitter=RandomSplitter(valid_pct=0.2, seed=42),\n    get_y=parent_label,\n    # car_bicycle_or_scooter/car/image1.jpg → label is \"car\"\n    # car_bicycle_or_scooter/bicycle/image2.jpg → label is \"bicycle\"\n    item_tfms=[Resize(192, method='squish')]\n).dataloaders(path, bs=32) \n\ndls.show_batch(max_n=6) # shows 6 images from a batch, displays both images and their labels\n\n\n\n\n\n\n\n\nNow we’re ready to train our model. The fastest widely used computer vision model is resnet18. You can train this in a few minutes,even on a CPU! (On a GPU, it generally takes under 10 seconds…)fastai comes with a helpful fine_tune() method which automatically uses best practices for fine tuning a pre-trained model, sowe’ll use that.\n\n# Create a vison learner using the DataLoaders we created above, resNet18 pre-trained model, and a metrics to measure the error rate.\nlearn = vision_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(3)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.727847\n0.032132\n0.010676\n00:01\n\n\n\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.083078\n0.038483\n0.003559\n00:01\n\n\n1\n0.046047\n0.027227\n0.003559\n00:01\n\n\n2\n0.023140\n0.021595\n0.003559\n00:01\n\n\n\n\n\n\n\nStep 3: Use our model\nLet’s see what the model thinks about the car we downloaded at the start:\n\nprint(\"Model classes:\", learn.dls.vocab)\n\nModel classes: ['bicycle', 'car', 'electric scooter']\n\n\n\nis_car,_,probs = learn.predict(PILImage.create('car.jpg'))\nprint(f\"This is a: {is_car}.\")\nprint(f\"Probability it's a car: {probs[1]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: car.\nProbability it's a car: 1.0000\n\n\n\nis_bicycle,_,probs = learn.predict(PILImage.create('bicycle.jpg'))\nprint(f\"This is a: {is_bicycle}.\")\nprint(f\"Probability it's a bicycle: {probs[0]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: bicycle.\nProbability it's a bicycle: 1.0000\n\n\n\nis_scooter,_,probs = learn.predict(PILImage.create('scooter.jpg'))\nprint(f\"This is a: {is_scooter}.\")\nprint(f\"Probability it's a scooter: {probs[2]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: electric scooter.\nProbability it's a scooter: 0.9997\n\n\nChecking the probability of car image being classified as a bicycle.\n\nis_car,_,probs = learn.predict(PILImage.create('car.jpg'))\nprint(f\"This is a: {is_car}.\")\nprint(f\"Probability it's a bicycle: {probs[0]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: car.\nProbability it's a bicycle: 0.0000\n\n\n\n\nFurther/future improvements\nData cleaning - manually removing unclear photos. Data augmentation Using a different pre-trained model Different learning rate Use more data?\nTo run the code yourself, check this kaggle notebook, where I’ve fine-tuned the model a 2nd time, then I’ve used resnet34."
  },
  {
    "objectID": "posts/01_intro/index.html#setting-up-our-ml-environment",
    "href": "posts/01_intro/index.html#setting-up-our-ml-environment",
    "title": "ML intro",
    "section": "Setting up our ML Environment",
    "text": "Setting up our ML Environment\nFirst, let’s install and import our required libraries:\n\n#hide\n! pip install -Uqq fastbook \nimport fastbook\nfrom fastbook import *\nfrom fastai.vision.all import *\n\nLoading and Preparing the Data"
  },
  {
    "objectID": "posts/01_intro/01_intro.html",
    "href": "posts/01_intro/01_intro.html",
    "title": "",
    "section": "",
    "text": "CodeShow All CodeHide All CodeView Source\n\n\n\n\n\n\nCode\n#hide\n!  pip install -Uqq fastbook \nimport fastbook\n\n\n\n\nCode\nfrom fastbook import *\n\n\n\n\nCode\nfrom fastai.vision.all import *\n#  downloads and extracts the Oxford-IIIT Pet Dataset, then sets the path to the 'images' subfolder\npath = untar_data(URLs.PETS)/'images' #The Pet dataset contains 7,390 pictures of dogs and cats, consisting of 37 different breeds.\n\n\n\n\nCode\n# labelling function -&gt; how to get labels from filenames\n\ndef is_cat(x): return x[0].isupper() # determnine if an image is of a cat\n\n# DataLoaders --&gt; path where the images are stored,  functions to fetch the images from the path, \n# validation 20%, seed, labelling function and resize \n# dataloaders object that contains the training and validation set\n\ndls = ImageDataLoaders.from_name_func(\n    path, get_image_files(path), valid_pct=0.2, seed=42,\n    label_func=is_cat, item_tfms=Resize(224)\n)\n\n# Why a CNN? It's the current state-of-the-art approach to creating computer vision models.\nlearn = vision_learner(dls, resnet34, metrics=error_rate) #  This creates a learner object, which is the fastai abstraction for a deep learning model\nlearn.fine_tune(1)  \n\n#This code sets up everything needed to train a model to classify images as cats or dogs \n#using transfer learning with a pre-trained ResNet34 model. \n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.164039\n0.029108\n0.008796\n00:08\n\n\n\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.057657\n0.024261\n0.006089\n00:29\n\n\n\n\n\n\n\nCode\npath # In this dataset, cat filenames start with an uppercase letter\n\n\nPath('/home/visi/.fastai/data/oxford-iiit-pet/images')\n\n\n\n\n\nimage.png\n\n\n\n\nCode\n# For the book, we can't actually click an upload button, so we fake it\nuploader = SimpleNamespace(data = ['cat_example.jpg'])\n\n\n\n\nCode\nimg = PILImage.create(uploader.data[0])\nis_cat,_,probs = learn.predict(img)\nprint(f\"Is this a cat?: {is_cat}.\")\nprint(f\"Probability it's a cat: {probs[1].item():.6f}\")\n\n\n\n\n\n\n\n\n\nIs this a cat?: True.\nProbability it's a cat: 1.000000\n\n\n# what is machine learning\n\n\nCode\n! pip install graphviz\ngv('''program[shape=box3d width=1 height=0.7]\ninputs-&gt;program-&gt;results''')\n\n\nRequirement already satisfied: graphviz in /home/visi/blog/.venv/lib/python3.12/site-packages (0.20.3)\n\n\n\n\n\n\n\n\n\nit is a way to get computers to do a specific task.\nNormally we have the inputs e.g. a=2, b=3 and in the program we write clear steps that we want the computer to execute, e.g. return a + b, then we get the results.\nIn ML we ask the computer to figure out/learn by itself how to complete the task.\nRecognizing images - hard to give specific instructions to the computer, since we have no idea how we are able to recognize objects/images ourselves, we simply know how to.\nWhy ML instead of the normal way we program?\nHaving to specify every single step of complicated tasks is well, complicated.\nArthur Samuel(1949) idea was:\n*instead of telling the computer the exact steps required to solve a problem, show it examples of the problem to solve, and let it figure out how to solve it itself.\n\n\nCode\ngv('''model[shape=box3d width=1 height=0.7]\ninputs-&gt;model-&gt;results; weights-&gt;model''')\n\n\n\n\n\n\n\n\n\n\n\nCode\ngv('''ordering=in\nmodel[shape=box3d width=1 height=0.7]\ninputs-&gt;model-&gt;results; weights-&gt;model; results-&gt;performance\nperformance-&gt;weights[constraint=false label=update]''')\n\n\n\n\n\n\n\n\n\ninputs are varibales that the Model processes to produce a result, e.g pixels of images and whether they are a dog or cat.\nModel can do many different things depending on the weights.For instance, in Samuel’s checkers program, different values of the weights would result in different checkers-playing strategies. Next, Samuel said we need an automatic means of testing the effectiveness of any current weight assignment in terms of actual performance. In the case of his checkers program, the “actual performance” of a model would be how well it plays. And you could automatically test the performance of two models by setting them to play against each other, and seeing which one usually wins.\nEach weight assignment has a performance.\nFinally, he says we need a mechanism for altering the weight assignment so as to maximize the performance. For instance, we could look at the difference in weights between the winning model and the losing model, and adjust the weights a little further in the winning direction.\nLearning - we can say that the machine is able to learn to solve a task by itself, because of these automated system. Automatically getting the performance of each of the assigned weights, then automatically altering those weights, so that the performance of the system improves.\nNotice the distinction between the model’s results (e.g., the moves in a checkers game) and its performance (e.g., whether it wins the game, or how quickly it wins).\nAlso note that once the model is trained—that is, once we’ve chosen our final, best, favorite weight assignment—then we can think of the weights as being part of the model, since we’re not varying them any more.\nTherefore, actually using a model after it’s trained looks like\n\n\nCode\ngv('''model[shape=box3d width=1 height=0.7]\ninputs-&gt;model-&gt;results''')\n\n\n\n\n\n\n\n\n\n\nWhat is a neural network\nWhat we would like is some kind of function that is so flexible that it could be used to solve any given problem, just by varying its weights. Amazingly enough, this function actually exists! It’s the neural network.\nA mathematical proof called the universal approximation theorem shows that this function can solve any problem to any level of accuracy, in theory. The fact that neural networks are so flexible means that, in practice, they are often a suitable kind of model, and you can focus your effort on the process of training them—that is, of finding good weight assignments.\nNeural networks are special because they are highly flexible, which means they can solve an unusually wide range of problems just by finding the right weights. This is powerful, because stochastic gradient descent provides us a way to find those weight values automatically.\n\n\napplying samuel’s framework to the image classification model\ninputs - images\nweights - weights of the neural net, resnet34\nModel - neural net, resnet34\nresults - values that are calculated by the neural net- dog/cat\nperformance - model’s accuracy at predicting the correct answers\nweights automaic update function - SGD\n\n\nCode\ngv('''ordering=in\nmodel[shape=box3d width=1 height=0.7 label=architecture]\ninputs-&gt;model-&gt;predictions; parameters-&gt;model; labels-&gt;loss; predictions-&gt;loss\nloss-&gt;parameters[constraint=false label=update]''')\n\n\n\n\n\n\n\n\n\nThe predictions are calculated from the independent variable, which is the data not including the labels.\nThe loss depends not only on the predictions, but also the correct labels (also known as targets or the dependent variable); e.g., “dog” or “cat.”\n\n\nLimitations inherent to Machine Learning\nFrom this picture we can now see some fundamental things about training a deep learning model:  * A model cannot be created without data. * A model can only learn to operate on the patterns seen in the input data used to train it. * This learning approach only creates predictions, not recommended actions. * It’s not enough to just have examples of input data; we need labels for that data too (e.g.,  pictures of dogs and cats aren’t enough to train a model; we need a label for each one, saying which ones are dogs, and which are cats).\n# How Our Image Recognizer Works\nA classification model is one which attempts to predict a class, or category. That is, it’s predicting from a number of discrete possibilities, such as “dog” or “cat.” A regression model is one which attempts to predict one or more numeric quantities, such as a temperature or a location.\n\n\noverfitting\nit is very easy to create a model that does a great job at making predictions on the exact data it has been trained on, but it is much harder to make accurate predictions on data the model has never seen before\n\n\n\nimage.png\n\n\nfunction x**2. As you can see, although the predictions in the overfit model are accurate for data near the observed data points, they are way off when outside of that range.\nValidation Set: When you train a model, you must always have both a training set and a validation set, and must measure the accuracy of your model only on the validation set. If you train for too long, with not enough data, you will see the accuracy of your model start to get worse; this is called overfitting."
  },
  {
    "objectID": "notebooks/01_intro.html",
    "href": "notebooks/01_intro.html",
    "title": "What is a neural network",
    "section": "",
    "text": "#hide\n!  pip install -Uqq fastbook --user\nimport fastbook\n\n\nfrom fastbook import *\n\n\nfrom fastai.vision.all import *\n#  downloads and extracts the Oxford-IIIT Pet Dataset, then sets the path to the 'images' subfolder\npath = untar_data(URLs.PETS)/'images' #The Pet dataset contains 7,390 pictures of dogs and cats, consisting of 37 different breeds.\n\n\n\n# labelling function -&gt; how to get labels from filenames\n\ndef is_cat(x): return x[0].isupper() # determnine if an image is of a cat\n\n# DataLoaders --&gt; path where the images are stored,  functions to fetch the images from the path, \n# validation 20%, seed, labelling function and resize \n# dataloaders object that contains the training and validation set\n\ndls = ImageDataLoaders.from_name_func(\n    path, get_image_files(path), valid_pct=0.2, seed=42,\n    label_func=is_cat, item_tfms=Resize(224)\n)\n\n# Why a CNN? It's the current state-of-the-art approach to creating computer vision models.\nlearn = vision_learner(dls, resnet34, metrics=error_rate) #  This creates a learner object, which is the fastai abstraction for a deep learning model\nlearn.fine_tune(1)  \n\n#This code sets up everything needed to train a model to classify images as cats or dogs \n#using transfer learning with a pre-trained ResNet34 model. \n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.168784\n0.026259\n0.012179\n00:28\n\n\n\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.061694\n0.017906\n0.003383\n00:30\n\n\n\n\n\n\npath # In this dataset, cat filenames start with an uppercase letter\n\nPath('C:/Users/elvis/.fastai/data/oxford-iiit-pet/images')\n\n\n\n\n\nimage.png\n\n\n\nimg = PILImage.create(image_cat())\nimg.to_thumb(192)\n\n\n\n\n\n\n\n\n\nuploader = widgets.FileUpload()\nuploader\n\n\n\n\n\nimport torch\n\n# Check if GPU is available\nif torch.cuda.is_available():\n    print(\"CUDA is available. You are using a GPU.\")\nelse:\n    print(\"CUDA is not available. You are using a CPU.\")\n\nCUDA is available. You are using a GPU.\n\n\n\nfrom pathlib import Path\n\ncurrent_directory = Path.cwd()\ncurrent_directory\n\nPath('C:/Users/elvis/AppData/Roaming/Python/Python312/Scripts')\n\n\n\n# For the book, we can't actually click an upload button, so we fake it\nuploader = SimpleNamespace(data = ['images/cat_example.jpg'])\n\n\nimg = PILImage.create(uploader.data[0])\nis_cat,_,probs = learn.predict(img)\nprint(f\"Is this a cat?: {is_cat}.\")\nprint(f\"Probability it's a cat: {probs[1].item():.6f}\")\n\n\n\n\n\n\n\n\nIs this a cat?: True.\nProbability it's a cat: 1.000000\n\n\n# what is machine learning\n\ngv('''program[shape=box3d width=1 height=0.7]\ninputs-&gt;program-&gt;results''')\n\n\n\n\n\n\n\n\nit is a way to get computers to do a specific task.\nNormally we have the inputs e.g. a=2, b=3 and in the program we write clear steps that we want the computer to execute, e.g. return a + b, then we get the results.\nIn ML we ask the computer to figure out/learn by itself how to complete the task.\nRecognizing images - hard to give specific instructions to the computer, since we have no idea how we are able to recognize objects/images ourselves, we simply know how to.\nWhy ML instead of the normal way we program?\nHaving to specify every single step of complicated tasks is well, complicated.\nArthur Samuel(1949) idea was:\n*instead of telling the computer the exact steps required to solve a problem, show it examples of the problem to solve, and let it figure out how to solve it itself.\n\ngv('''model[shape=box3d width=1 height=0.7]\ninputs-&gt;model-&gt;results; weights-&gt;model''')\n\n\n\n\n\n\n\n\n\ngv('''ordering=in\nmodel[shape=box3d width=1 height=0.7]\ninputs-&gt;model-&gt;results; weights-&gt;model; results-&gt;performance\nperformance-&gt;weights[constraint=false label=update]''')\n\n\n\n\n\n\n\n\ninputs are varibales that the Model processes to produce a result, e.g pixels of images and whether they are a dog or cat.\nModel can do many different things depending on the weights.For instance, in Samuel’s checkers program, different values of the weights would result in different checkers-playing strategies. Next, Samuel said we need an automatic means of testing the effectiveness of any current weight assignment in terms of actual performance. In the case of his checkers program, the “actual performance” of a model would be how well it plays. And you could automatically test the performance of two models by setting them to play against each other, and seeing which one usually wins.\nEach weight assignment has a performance.\nFinally, he says we need a mechanism for altering the weight assignment so as to maximize the performance. For instance, we could look at the difference in weights between the winning model and the losing model, and adjust the weights a little further in the winning direction.\nLearning - we can say that the machine is able to learn to solve a task by itself, because of these automated system. Automatically getting the performance of each of the assigned weights, then automatically altering those weights, so that the performance of the system improves.\nNotice the distinction between the model’s results (e.g., the moves in a checkers game) and its performance (e.g., whether it wins the game, or how quickly it wins).\nAlso note that once the model is trained—that is, once we’ve chosen our final, best, favorite weight assignment—then we can think of the weights as being part of the model, since we’re not varying them any more.\nTherefore, actually using a model after it’s trained looks like\n\ngv('''model[shape=box3d width=1 height=0.7]\ninputs-&gt;model-&gt;results''')\n\n\n\n\n\n\n\n\n\nWhat is a neural network\nWhat we would like is some kind of function that is so flexible that it could be used to solve any given problem, just by varying its weights. Amazingly enough, this function actually exists! It’s the neural network.\nA mathematical proof called the universal approximation theorem shows that this function can solve any problem to any level of accuracy, in theory. The fact that neural networks are so flexible means that, in practice, they are often a suitable kind of model, and you can focus your effort on the process of training them—that is, of finding good weight assignments.\nNeural networks are special because they are highly flexible, which means they can solve an unusually wide range of problems just by finding the right weights. This is powerful, because stochastic gradient descent provides us a way to find those weight values automatically.\n\n\napplying samuel’s framework to the image classification model\ninputs - images\nweights - weights of the neural net, resnet34\nModel - neural net, resnet34\nresults - values that are calculated by the neural net- dog/cat\nperformance - model’s accuracy at predicting the correct answers\nweights automaic update function - SGD\n\ngv('''ordering=in\nmodel[shape=box3d width=1 height=0.7 label=architecture]\ninputs-&gt;model-&gt;predictions; parameters-&gt;model; labels-&gt;loss; predictions-&gt;loss\nloss-&gt;parameters[constraint=false label=update]''')\n\n\n\n\n\n\n\n\nThe predictions are calculated from the independent variable, which is the data not including the labels.\nThe loss depends not only on the predictions, but also the correct labels (also known as targets or the dependent variable); e.g., “dog” or “cat.”\n\n\nLimitations inherent to Machine Learning\nFrom this picture we can now see some fundamental things about training a deep learning model:  * A model cannot be created without data. * A model can only learn to operate on the patterns seen in the input data used to train it. * This learning approach only creates predictions, not recommended actions. * It’s not enough to just have examples of input data; we need labels for that data too (e.g.,  pictures of dogs and cats aren’t enough to train a model; we need a label for each one, saying which ones are dogs, and which are cats).\n# How Our Image Recognizer Works\nA classification model is one which attempts to predict a class, or category. That is, it’s predicting from a number of discrete possibilities, such as “dog” or “cat.” A regression model is one which attempts to predict one or more numeric quantities, such as a temperature or a location.\n\n\noverfitting\nit is very easy to create a model that does a great job at making predictions on the exact data it has been trained on, but it is much harder to make accurate predictions on data the model has never seen before\n\n\n\nimage.png\n\n\nfunction x**2. As you can see, although the predictions in the overfit model are accurate for data near the observed data points, they are way off when outside of that range.\nValidation Set: When you train a model, you must always have both a training set and a validation set, and must measure the accuracy of your model only on the validation set. If you train for too long, with not enough data, you will see the accuracy of your model start to get worse; this is called overfitting."
  },
  {
    "objectID": "posts/01_intro/01-own-model.html",
    "href": "posts/01_intro/01-own-model.html",
    "title": "Step 1: Download images of cars, bikes and electric scooters",
    "section": "",
    "text": "::: {#ba345b69 .cell _cell_guid=‘b1076dfc-b9ad-4769-8c92-a6c4dae69d19’ _uuid=‘8f2839f25d086af736a60e9eeb907d3b93b6e0e5’ execution=‘{“iopub.execute_input”:“2024-10-23T07:40:43.709449Z”,“iopub.status.busy”:“2024-10-23T07:40:43.709045Z”,“iopub.status.idle”:“2024-10-23T07:40:43.733800Z”,“shell.execute_reply”:“2024-10-23T07:40:43.732746Z”,“shell.execute_reply.started”:“2024-10-23T07:40:43.709407Z”}’ execution_count=1}\n# Input data files are available in the read-only \"../input/\" directory# For example, running this (by clicking run or pressing Shift+Enter) will list all files under the input directoryimport osfor dirname, _, filenames in os.walk('/kaggle/input'):    for filename in filenames:        print(os.path.join(dirname, filename))# You can write up to 20GB to the current directory (/kaggle/working/) that gets preserved as output when you create a version using \"Save & Run All\" # You can also write temporary files to /kaggle/temp/, but they won't be saved outside of the current session\n:::\n\nUse DuckDuckGo to search for images of “car”\nUse DuckDuckGo to search for images of “bicycle”\nUse DuckDuckGo to search for images of “electric scooter”\ntry running this model on a picture of car and see if it works\n\n\n! pip install duckduckgo-search\n\nRequirement already satisfied: duckduckgo-search in /home/visi/blog/.venv/lib/python3.12/site-packages (6.3.2)\nRequirement already satisfied: click&gt;=8.1.7 in /home/visi/blog/.venv/lib/python3.12/site-packages (from duckduckgo-search) (8.1.7)\nRequirement already satisfied: primp&gt;=0.6.4 in /home/visi/blog/.venv/lib/python3.12/site-packages (from duckduckgo-search) (0.6.4)\n\n\n\nfrom duckduckgo_search import DDGS\nfrom fastcore.all import *\ndef search_images(term, max_images=30):    \n    \"\"\"    Search for images using DuckDuckGo's search engine        Parameters:    - term: search term/query (e.g., \"cars\", \"bikes\")    - max_images: maximum number of images to return (default 30)        Returns:    - List of image URLs    \"\"\"       \n    print(f\"Searching for '{term}'\")    \n    with DDGS() as ddgs: \n        #Create a DuckDuckGo search session        \n        # 1. ddgs.images(term, max_results=max_images) - Search for images        # 2. L(...) - Convert results to fastcore's List type        # 3. .itemgot('image') - Extract just the image URLs        \n        return L(ddgs.images(term, max_results=max_images)).itemgot('image')\n\nLet’s start by searching for a car photo and seeing what kind of result we get. We’ll start by getting URLs from a search:\n\n# get images urls, in this case just 1 url\nurls =  search_images('car photos',max_images=1)\nurls[0]\n\nSearching for 'car photos'\n\n\n'https://images.pexels.com/photos/63764/pexels-photo-63764.jpeg?cs=srgb&dl=car-cars-lamborghini-aventador-63764.jpg&fm=jpg'\n\n\n..and then download a URL and take a look at it:Now let’s do the same with “bicycle” and “electric scooter”:\n\nfrom fastdownload import download_url\ndest = 'car.jpg'\ndownload_url(urls[0], dest, show_progress=False)\n\nfrom fastai.vision.all import *\nim = Image.open(dest)\nim.to_thumb(256,256)\n\n\n\n\n\n\n\n\nNow let’s do the same with “bicycle”:\n\ndownload_url(search_images('bicycle photos', max_images=1)[0], 'bicycle.jpg', show_progress=False)\nImage.open('bicycle.jpg').to_thumb(256,256)\n\nSearching for 'bicycle photos'\n\n\n\n\n\n\n\n\n\nThe same with electric scooters\n\ndownload_url(search_images('electric scooter photos', max_images=1)[0], 'scooter.jpg', show_progress=False)\nImage.open('scooter.jpg').to_thumb(256,256)\n\nSearching for 'electric scooter photos'\n\n\n\n\n\n\n\n\n\nOur searches seem to be giving reasonable results. Let’s grab a few examples of each of “car”, “bicycle” and “electric scooter” photos and save each group of photos to a different folder. We will search for day and night photos to grab a range of lighting conditions.\n\nsearches = 'car','bicycle','electric scooter'\npath = Path('car_bicycle_or_scooter')\nfrom time import sleep\n\nfor o in searches:\n    # destination, create a directory if it doesnt exist, then download images for the o term\n    # resize the images \n    dest = path/o # car_bicycle_or_scooter/car \n    dest.mkdir(exist_ok=True, parents=True)\n    download_images(dest, urls=search_images(f'{o} photo'))\n    sleep(10)  # Pause between searches to avoid over-loading server\n    download_images(dest, urls=search_images(f'{o} sun photo'))\n    sleep(10)\n    download_images(dest, urls=search_images(f'{o} shade photo'))\n    sleep(10)\n    resize_images(path/o, max_size=400, dest=path/o)     \n\nSearching for 'car photo'\nSearching for 'car sun photo'\nSearching for 'car shade photo'\nSearching for 'bicycle photo'\nSearching for 'bicycle sun photo'\nSearching for 'bicycle shade photo'\nSearching for 'electric scooter photo'\nSearching for 'electric scooter sun photo'\nSearching for 'electric scooter shade photo'\n\n\n/home/visi/blog/.venv/lib/python3.12/site-packages/PIL/Image.py:1054: UserWarning: Palette images with Transparency expressed in bytes should be converted to RGBA images\n  warnings.warn(\n\n\n\n\n\nAlt Text\n\n\n\nStep 2: train our model\nSome photos might not download correctly which could cause our model training to fail, so we’ll remove them:\n\nfailed = verify_images(get_image_files(path))\nfailed.map(Path.unlink)\nlen(failed)\n\n29\n\n\nTo train a model, we’ll need DataLoaders, which is an object that contains a training set(the images used to create the model) and a validation set(the images used to check the accuracy of a model) What goes into the DataLoaders object? Out of hundreds of projects what are all the things that change from project to project to get the data in the right shape? We could basically split it down into these five things. 1. What kind of input and output do we have? Input- images. Output- categories, a number of possibities(car, bicycle, electric scooter)2. get_items -&gt; Gets all image files from the specified path, run the get_image_files function (which returns a list of all image files in a path). Looks through directories recursively3. Splitter -Split the data into training and validation sets randomly, using 20% of the data for the validation set.4. get_y=parent_label - Uses the parent folder name as the category label5. Before training, resize each image to 192x192 pixels by “squishing” it (as opposed to cropping it).’squish’ method maintains aspect ratio6. dataloaders(path, bs=32) - Creates train and validation dataloaders, bs=32 means batch size of 32 images.\n\ndls = DataBlock(\n    blocks=(ImageBlock, CategoryBlock), \n    get_items=get_image_files, \n    splitter=RandomSplitter(valid_pct=0.2, seed=42),\n    get_y=parent_label,\n    # car_bicycle_or_scooter/car/image1.jpg → label is \"car\"\n    # car_bicycle_or_scooter/bicycle/image2.jpg → label is \"bicycle\"\n    item_tfms=[Resize(192, method='squish')]\n).dataloaders(path, bs=32) \n\ndls.show_batch(max_n=6) # shows 6 images from a batch, displays both images and their labels\n\n\n\n\n\n\n\n\nNow we’re ready to train our model. The fastest widely used computer vision model is resnet18. You can train this in a few minutes,even on a CPU! (On a GPU, it generally takes under 10 seconds…)fastai comes with a helpful fine_tune() method which automatically uses best practices for fine tuning a pre-trained model, sowe’ll use that.\n\n# Create a vison learner using the DataLoaders we created above, resNet18 pre-trained model, and a metrics to measure the error rate.\nlearn = vision_learner(dls, resnet18, metrics=error_rate)\nlearn.fine_tune(3)\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n1.042422\n0.153208\n0.049645\n00:01\n\n\n\n\n\n\n\n\n\n\n\n\nepoch\ntrain_loss\nvalid_loss\nerror_rate\ntime\n\n\n\n\n0\n0.129953\n0.031034\n0.014184\n00:01\n\n\n1\n0.088246\n0.064510\n0.035461\n00:01\n\n\n2\n0.061246\n0.048250\n0.035461\n00:01\n\n\n\n\n\nFirst row - initial training with high error rate, 12.7%, indicates the model is just starting to learn.\n1. Loss Trends:\n* Train_loss: 1.70 → 0.60 → 0.36 → 0.25 * Valid_loss: 0.36 → 0.21 → 0.15 → 0.16 * Both losses consistently decreasing 2. Error Rate Pattern: * Big improvement in first fine-tuning epoch (12.77% → 4.26%) * After the other epochs, no fluctuation at all in error rate. 3. Model Performance: * Final error rate of 4.26% is quite good * Might have reached optimal performance for this architecture/dataset, judging by the error rate decreasing after the first epoch, then not changing at all.\nConclusion:\n1. Model has converged 2. Dataset might be small 3. Further training probably won’t improve performance\nError Rate vs Loss:\nError rate is binary (right or wrong prediction) Loss measures the model’s confidence/uncertainty\nExample: Prediction 1: Car (60% confident) ✓ Correct Prediction 2: Car (95% confident) ✓ Still Correct\n* Both have same error rate (0% - both correct) * But second prediction has lower loss (more confident)\nWhat’s happening in our case:\nEpoch 0: 4.26% error, but less confident predictions Epoch 1: 4.26% error, but more confident predictions Epoch 2: 4.26% error, but even more confident predictions\nLoss Improvement Means:\n\nModel is getting more confident in its correct predictions\nLess uncertainty in its decisions\nBetter internal representations - how the neural network understands and represents features in the data.\nEarly training: Model: “This is a car because it has wheels” (less confident, higher loss)\n\nLater training: Model: “This is a car because it has wheels, specific body shape, headlights, and typical car proportions” (more confident, lower loss)\n\nBut not enough to change the actual right/wrong decisions (error rate)\n\nThis is actually healthy behavior - the model is becoming more robust even though the error rate isn’t changing.\nTO be revisited in the future. Data cleaning, data augmentation, different models, different learning rate.\n\n\nStep 3: Use our model\nLet’s see what the model thinks about the car we downloaded at the start:\n\nprint(\"Model classes:\", learn.dls.vocab)\n\nModel classes: ['bicycle', 'car', 'electric scooter']\n\n\n\nis_car,_,probs = learn.predict(PILImage.create('car.jpg'))\nprint(f\"This is a: {is_car}.\")\nprint(f\"Probability it's a car: {probs[1]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: car.\nProbability it's a car: 0.9999\n\n\n\nis_bicycle,_,probs = learn.predict(PILImage.create('bicycle.jpg'))\nprint(f\"This is a: {is_bicycle}.\")\nprint(f\"Probability it's a bicycle: {probs[0]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: bicycle.\nProbability it's a bicycle: 1.0000\n\n\n\nis_scooter,_,probs = learn.predict(PILImage.create('scooter.jpg'))\nprint(f\"This is a: {is_scooter}.\")\nprint(f\"Probability it's a scooter: {probs[2]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: electric scooter.\nProbability it's a scooter: 1.0000\n\n\nChecking the probability of car image being classified as a bicycle.\n\nis_car,_,probs = learn.predict(PILImage.create('car.jpg'))\nprint(f\"This is a: {is_car}.\")\nprint(f\"Probability it's a bicycle: {probs[0]:.4f}\")\n\n\n\n\n\n\n\n\nThis is a: car.\nProbability it's a bicycle: 0.0000"
  }
]