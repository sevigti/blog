{
  "hash": "600a9b956e4b469ada7fceb733de04cc",
  "result": {
    "engine": "jupyter",
    "markdown": "---\njupyter: python3\n---\n\n::: {#fff53160 .cell execution_count=1}\n``` {.python .cell-code}\n#hide\n!  pip install -Uqq fastbook \nimport fastbook\n```\n:::\n\n\n::: {#361abc0e .cell execution_count=2}\n``` {.python .cell-code}\nfrom fastbook import *\n```\n:::\n\n\n::: {#9f3c0a65 .cell execution_count=3}\n``` {.python .cell-code}\nfrom fastai.vision.all import *\n#  downloads and extracts the Oxford-IIIT Pet Dataset, then sets the path to the 'images' subfolder\npath = untar_data(URLs.PETS)/'images' #The Pet dataset contains 7,390 pictures of dogs and cats, consisting of 37 different breeds.\n```\n:::\n\n\n::: {#ab5ed0b7 .cell execution_count=4}\n``` {.python .cell-code}\n# labelling function -> how to get labels from filenames\n\ndef is_cat(x): return x[0].isupper() # determnine if an image is of a cat\n\n# DataLoaders --> path where the images are stored,  functions to fetch the images from the path, \n# validation 20%, seed, labelling function and resize \n# dataloaders object that contains the training and validation set\n\ndls = ImageDataLoaders.from_name_func(\n    path, get_image_files(path), valid_pct=0.2, seed=42,\n    label_func=is_cat, item_tfms=Resize(224)\n)\n\n# Why a CNN? It's the current state-of-the-art approach to creating computer vision models.\nlearn = vision_learner(dls, resnet34, metrics=error_rate) #  This creates a learner object, which is the fastai abstraction for a deep learning model\nlearn.fine_tune(1)  \n\n#This code sets up everything needed to train a model to classify images as cats or dogs \n#using transfer learning with a pre-trained ResNet34 model. \n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n<style>\n    /* Turns off some styling */\n    progress {\n        /* gets rid of default border in Firefox and Opera. */\n        border: none;\n        /* Needs to be in here for Safari polyfill so background images work as expected. */\n        background-size: auto;\n    }\n    progress:not([value]), progress:not([value])::-webkit-progress-bar {\n        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);\n    }\n    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {\n        background: #F44336;\n    }\n</style>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: left;\">\n      <th>epoch</th>\n      <th>train_loss</th>\n      <th>valid_loss</th>\n      <th>error_rate</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>0.164039</td>\n      <td>0.029108</td>\n      <td>0.008796</td>\n      <td>00:08</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n<style>\n    /* Turns off some styling */\n    progress {\n        /* gets rid of default border in Firefox and Opera. */\n        border: none;\n        /* Needs to be in here for Safari polyfill so background images work as expected. */\n        background-size: auto;\n    }\n    progress:not([value]), progress:not([value])::-webkit-progress-bar {\n        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);\n    }\n    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {\n        background: #F44336;\n    }\n</style>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n<table border=\"1\" class=\"dataframe\">\n  <thead>\n    <tr style=\"text-align: left;\">\n      <th>epoch</th>\n      <th>train_loss</th>\n      <th>valid_loss</th>\n      <th>error_rate</th>\n      <th>time</th>\n    </tr>\n  </thead>\n  <tbody>\n    <tr>\n      <td>0</td>\n      <td>0.057657</td>\n      <td>0.024261</td>\n      <td>0.006089</td>\n      <td>00:29</td>\n    </tr>\n  </tbody>\n</table>\n```\n:::\n:::\n\n\n::: {#0c5de209 .cell jupyter='{\"source_hidden\":true}' execution_count=5}\n``` {.python .cell-code}\npath # In this dataset, cat filenames start with an uppercase letter\n```\n\n::: {.cell-output .cell-output-display execution_count=5}\n```\nPath('/home/visi/.fastai/data/oxford-iiit-pet/images')\n```\n:::\n:::\n\n\n![image.png](attachment:b2f90df6-636b-45b8-9bae-9725f25e48d6.png)\n\n::: {#56481bda .cell execution_count=6}\n``` {.python .cell-code}\n# For the book, we can't actually click an upload button, so we fake it\nuploader = SimpleNamespace(data = ['cat_example.jpg'])\n```\n:::\n\n\n::: {#fed540e5 .cell execution_count=7}\n``` {.python .cell-code}\nimg = PILImage.create(uploader.data[0])\nis_cat,_,probs = learn.predict(img)\nprint(f\"Is this a cat?: {is_cat}.\")\nprint(f\"Probability it's a cat: {probs[1].item():.6f}\")\n```\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n<style>\n    /* Turns off some styling */\n    progress {\n        /* gets rid of default border in Firefox and Opera. */\n        border: none;\n        /* Needs to be in here for Safari polyfill so background images work as expected. */\n        background-size: auto;\n    }\n    progress:not([value]), progress:not([value])::-webkit-progress-bar {\n        background: repeating-linear-gradient(45deg, #7e7e7e, #7e7e7e 10px, #5c5c5c 10px, #5c5c5c 20px);\n    }\n    .progress-bar-interrupted, .progress-bar-interrupted::-webkit-progress-bar {\n        background: #F44336;\n    }\n</style>\n```\n:::\n\n::: {.cell-output .cell-output-display}\n```{=html}\n\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nIs this a cat?: True.\nProbability it's a cat: 1.000000\n```\n:::\n:::\n\n\n # what is machine learning \n\n::: {#cb78f9be .cell execution_count=8}\n``` {.python .cell-code}\n! pip install graphviz\ngv('''program[shape=box3d width=1 height=0.7]\ninputs->program->results''')\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nRequirement already satisfied: graphviz in /home/visi/blog/.venv/lib/python3.12/site-packages (0.20.3)\r\n```\n:::\n\n::: {.cell-output .cell-output-display execution_count=8}\n![](01_intro_files/figure-html/cell-9-output-2.svg){}\n:::\n:::\n\n\nit is a way to get computers to do a specific task.  \nNormally we have the inputs e.g. a=2, b=3  and in the program we write clear steps that we want the computer to execute,\ne.g. return a + b, then we get the results.  \nIn ML we ask the computer to figure out/learn by itself how to complete the task.   \nRecognizing images - hard to give specific instructions to the computer, since we have no idea how we are able to recognize objects/images ourselves, we simply know how to.   \n\nWhy ML instead of the normal way we program?  \nHaving to specify every single step of complicated tasks is well, complicated.  \n\nArthur Samuel(1949) idea was:  \n*instead of telling the computer the exact steps required to solve a problem, show it examples of the problem to solve, and let it figure out how to solve it itself. \n\n::: {#15dbc8c6 .cell execution_count=9}\n``` {.python .cell-code}\ngv('''model[shape=box3d width=1 height=0.7]\ninputs->model->results; weights->model''')\n```\n\n::: {.cell-output .cell-output-display execution_count=9}\n![](01_intro_files/figure-html/cell-10-output-1.svg){}\n:::\n:::\n\n\n::: {#9764ef63 .cell execution_count=10}\n``` {.python .cell-code}\ngv('''ordering=in\nmodel[shape=box3d width=1 height=0.7]\ninputs->model->results; weights->model; results->performance\nperformance->weights[constraint=false label=update]''')\n```\n\n::: {.cell-output .cell-output-display execution_count=10}\n![](01_intro_files/figure-html/cell-11-output-1.svg){}\n:::\n:::\n\n\ninputs are varibales that the Model processes to produce a result, e.g pixels of images and whether they are a dog or cat.   \n\nModel can do many different things depending on the weights.For instance, in Samuel's checkers program, different values of the weights would result in different checkers-playing strategies.\nNext, Samuel said we need an automatic means of testing the effectiveness of any current weight assignment in terms of actual performance. In the case of his checkers program, the \"actual performance\" of a model would be how well it plays. And you could automatically test the performance of two models by setting them to play against each other, and seeing which one usually wins.  \nEach weight assignment has a performance.   \nFinally, he says we need a mechanism for altering the weight assignment so as to maximize the performance. For instance, we could look at the difference in weights between the winning model and the losing model, and adjust the weights a little further in the winning direction. \n\n<span style=\"color:purple\">Learning - we can say that the machine is able to learn to solve a task by itself, because of these automated system. Automatically getting the performance of each of the assigned weights, then automatically altering those weights, so that the performance of the system improves.</span>  \n\nNotice the distinction between the model's results (e.g., the moves in a checkers game) and its performance (e.g., whether it wins the game, or how quickly it wins).  \n\nAlso note that once the model is trained—that is, once we've chosen our final, best, favorite weight assignment—then we can think of the weights as being part of the model, since we're not varying them any more.\n\nTherefore, actually using a model after it's trained looks like\n\n::: {#07851a50 .cell execution_count=11}\n``` {.python .cell-code}\ngv('''model[shape=box3d width=1 height=0.7]\ninputs->model->results''')\n```\n\n::: {.cell-output .cell-output-display execution_count=11}\n![](01_intro_files/figure-html/cell-12-output-1.svg){}\n:::\n:::\n\n\n# What is a neural network\n\nWhat we would like is some kind of function that is so flexible that it could be used to solve any given problem, just by varying its weights. Amazingly enough, this function actually exists! It's the neural network.  \n A mathematical proof called the universal approximation theorem shows that this function can solve any problem to any level of accuracy, in theory. The fact that neural networks are so flexible means that, in practice, they are often a suitable kind of model, and you can focus your effort on the process of training them—that is, of finding good weight assignments.  \n\nNeural networks are special because they are highly flexible, which means they can solve an unusually wide range of problems just by finding the right weights. This is powerful, because stochastic gradient descent provides us a way to find those weight values automatically.\n\n# applying samuel's framework to the image classification model  \n\ninputs - images  \nweights - weights of the neural net, resnet34  \nModel - neural net, resnet34  \nresults - values that are calculated by the neural net- dog/cat  \nperformance - model's accuracy at predicting the correct answers  \nweights automaic update function - SGD  \n\n::: {#aa41a84d .cell execution_count=12}\n``` {.python .cell-code}\ngv('''ordering=in\nmodel[shape=box3d width=1 height=0.7 label=architecture]\ninputs->model->predictions; parameters->model; labels->loss; predictions->loss\nloss->parameters[constraint=false label=update]''')\n```\n\n::: {.cell-output .cell-output-display execution_count=12}\n![](01_intro_files/figure-html/cell-13-output-1.svg){}\n:::\n:::\n\n\nThe predictions are calculated from the independent variable, which is the data not including the labels.  \nThe loss depends not only on the predictions, but also the correct labels (also known as targets or the dependent variable); e.g., \"dog\" or \"cat.\"\n\n# Limitations inherent to Machine Learning  \n\n\n**From this picture we can now see some fundamental things about training a deep learning model:\n**\n* A model cannot be created without data.\n* A model can only learn to operate on the patterns seen in the input data used to train it.\n* This learning approach only creates predictions, not recommended actions.\n* It's not enough to just have examples of input data; we need labels for that data too (e.g., <span style=\"color:purple\">\npictures of dogs and cats aren't enough to train a model; we need a label for each one, saying which ones are dogs, and which are cats).</span>\n\n\n # How Our Image Recognizer Works\n\nA classification model is one which attempts to predict a class, or category. That is, it's predicting from a number of discrete possibilities, such as \"dog\" or \"cat.\" A regression model is one which attempts to predict one or more numeric quantities, such as a temperature or a location.\n\n# overfitting\n\nit is very easy to create a model that does a great job at making predictions on the exact data it has been trained on, but it is much harder to make accurate predictions on data the model has never seen before  \n\n\n![image.png](attachment:fac41b74-5d19-45a3-98cc-4d703a500532.png)  \n\nfunction x**2. As you can see, although the predictions in the overfit model are accurate for data near the observed data points, they are way off when outside of that range.  \n\nValidation Set: When you train a model, you must always have both a training set and a validation set, and must measure the accuracy of your model only on the validation set. If you train for too long, with not enough data, you will see the accuracy of your model start to get worse; this is called overfitting.\n\n",
    "supporting": [
      "01_intro_files"
    ],
    "filters": [],
    "includes": {
      "include-in-header": [
        "<script src=\"https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js\" integrity=\"sha512-c3Nl8+7g4LMSTdrm621y7kf9v3SDPnhxLNhcjFJbKECVnmZHTdo+IRO05sNLTH/D3vA6u1X32ehoLC7WFVdheg==\" crossorigin=\"anonymous\"></script>\n<script src=\"https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js\" integrity=\"sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==\" crossorigin=\"anonymous\" data-relocate-top=\"true\"></script>\n<script type=\"application/javascript\">define('jquery', [],function() {return window.jQuery;})</script>\n"
      ]
    }
  }
}